---
layout: post
title: 排序
---

{{ page.title }}
================

<p class="meta">{{ page.date | date_to_string }} - Changsha</p>

> _内容来自https://www.cnblogs.com/onepixel/p/7674659.html_

常用的排序算法分为两类：
+ 比较类排序：时间复杂度不能突破O(nlogn)
+ 非比较类排序：以线性时间运行  
![avatar](/images/posts/2019-03-10/sortCategory.png)  

算法复杂度  
![avatar](/images/posts/2019-03-10/time.png)  

相关概念  
+ 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
+ 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
+ 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
+ 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 

冒泡排序（Bubble Sort） 
  + 思路：小的往上浮，大的往下沉
  + 动图  
  ![avatar](/images/posts/2019-03-10/bubbleSort.gif)
  + 代码   
  ```java  
  import java.util.Scanner;
  public class BubbleSort {
      public static int[] bubbleSort(int[] arr) {
          //比较length-1轮
          for (int i = 0; i < arr.length - 1; i++) {
              //每轮比较length-1-i次
              for (int j = 0; j < arr.length - 1 - i; j++) {
                  if (arr[j] > arr[j + 1]) {
                      int tmp = arr[j];
                      arr[j] = arr[j + 1];
                      arr[j + 1] = tmp;
                  }
              }
          }
          return arr;
      }
      public static void main(String[] args) {
          Scanner sc = new Scanner(System.in);
          while (sc.hasNextInt()) {
              int[] a = new int[5];
              for (int i = 0; i < a.length; i++) {
                  a[i] = sc.nextInt();
              }
              a = bubbleSort(a);
              for (int i = 0; i < a.length; i++) {
                  System.out.println(a[i]);
              }
          }
      }
  }
  ```
快速排序
  + 代码：
  ```java
  /**
   * @author Chris Chen
   * @date 2019/4/21 下午6:08
   */
  public class QuickSort {
  
      public static int[] swap(int[] arr, int i, int j) {
          int tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
          return arr;
      }
  
      public static int partition(int[] arr, int left, int right) {
          int pivot = left;
          int index = pivot + 1;
          for (int i = index; i <= right; i++) {
              if(arr[i]<arr[pivot]){
                  swap(arr, index, i);
                  index++;
              }
          }
          swap(arr, pivot, index-1);
          return index-1;
      }
  
      public static int[] quickSort(int[] arr, int left, int right) {
          if (left < right) {
              int partitionIndex = partition(arr, left, right);
              quickSort(arr, left, partitionIndex-1);
              quickSort(arr, partitionIndex+1, right);
          }
          return arr;
      }
  
      public static void main(String[] args){
          int[] a  = {4, 3, 6 ,5 ,2, 1};
          a = quickSort(a, 0, 5);
          for (int i=0; i< a.length; i++){
              System.out.println(a[i]);
          }
      }
  }

  ```
+ 选择排序
  + 代码：  
  ```java 
  /**
   * @author Chris Chen
   * @date 2019/4/22 上午12:27
   */
  public class SelectionSort {
  
      public static int[] selectionSort(int[] arr){
          for(int i=0;i<arr.length-1;i++){
              int minIndex = i;
              for(int j=i+1;j<arr.length;j++){
                  if(arr[j]<arr[minIndex]){
                      minIndex = j;
                  }
              }
              int tmp = arr[i];
              arr[i] = arr[minIndex];
              arr[minIndex] = tmp;
          }
          return arr;
      }
  
      public static void main(String[] args) {
          int[] a = {4, 3, 5, 6, 2, 1};
          a = selectionSort(a);
          for (int i=0;i<a.length;i++){
              System.out.println(a[i]);
          }
      }
  }

  ```
+ 堆排序：  
  + 代码：  
  ```java 
  /**
   * @author Chris Chen
   * @date 2019/4/22 上午1:30
   */
  public class HeapSort {
  
      public static void swap(int[] arr, int i, int j){
          int tmp = arr[i];
          arr[i] = arr[j];
          arr[j]=tmp;
      }
  
      /*
      堆调整
       */
      public static void heapify(int[] arr, int i,int len){
          //int len = arr.length;
          int left = 2 * i + 1;
          int right = 2 * i + 2;
          int largest = i;
  
          if (left<len ){
              if(arr[left]>arr[largest]){
                  largest = left;
              }
  
          }
  
          if (right < len ){
              if(arr[right]>arr[largest]){
                  largest = right;
              }
          }
  
          if(largest != i){
              swap(arr, largest, i);
              heapify(arr, largest, len);
          }
  
      }
  
      /*
      1. 建立最大顶堆
       */
      public static void buildMaxHeap(int[] arr, int len){
          //int len = arr.length;
          for (int i=len/2;i>=0;i--){
              heapify(arr,i, len);
          }
      }
  
  
      public static int[] heapSort(int[] arr){
          int len = arr.length;
          buildMaxHeap(arr, len);
  
  
          for (int i=arr.length-1;i>0;i--){
              swap(arr,0, i);
              len--;
              heapify(arr, 0, len);
          }
          return arr;
      }
  
      public static void main(String[] args) {
          int[] a={4, 3, 5, 6, 2, 1};
          a = heapSort(a);
          for (int i=0;i<a.length;i++){
              System.out.println(a[i]);
          }
      }
  }

  ```